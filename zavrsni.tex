\documentclass[times, utf8, zavrsni]{fer}

\usepackage{booktabs}
\usepackage{indentfirst}
\usepackage{listings}

\lstset{
  xleftmargin=.15\textwidth,
  xrightmargin=.15\textwidth
}

\begin{document}

\thesisnumber{5191}
\title{Primjena paradigme poslužiteljskih dojava u razvoju web-usluga}
\author{Karlo Vrbić}

\maketitle

% Dodavanje zahvale ili prazne stranice. Ako ne želite dodati zahvalu, naredbu ostavite radi prazne stranice.
\zahvala{}

\tableofcontents

\chapter{Uvod}

U 21. stoljeću svjedočimo sve bržem razvoju tehnologija u svim područjima, a najviše na području informacijskih tehnologija i mobilnih tehnologija. Danas je nezamisliv život bez mobilnih uređaja poput prijenosnih računala, pametnih mobitela, tableta, pametnih satova, itd. To potvrđuje podatak da 60\% ljudi posjeduje mobilni telefon i da danas većina ljudi internetu pristupa pomoću mobilnih uređaja. Do tako drastičnog porasta broja korisnika mobilnih uređaja došlo je ponajviše razvojem tzv. pametnih mobitela. Danas tržištem dominiraju Android i iOS pametni mobilni uređaji koji korisniku pružaju mnoge mogućnosti koje nisu bile dostupne tradicionalnim mobilnim telefonima. Uz razvoj mobilnih mreža i bežičnog interneta korisnicima je omogućeno da budu spojeni na internet bez obzira na vrijeme i mjesto gdje se nalaze. Ti podatci drastično mijenjaju način na koji korisnici koriste svoje uređaje. Od uređaja se više ne zahtjeva samo da može pristupiti informacijama bitnih korisniku nego i da može primati informacije iz više izvora u tren kada te informacije budu dostupne. Standardna klijentsko-poslužnička arhitektura ne zadovoljava tim uvjeta i u tome je motivacija za razvoj tehnologija poslužiteljskih dojava.


\chapter{Tehnologije poslužiteljskih dojava}

\section{Comet}
U početcima World Wide Web tehnologije internet preglednici za svaku stranicu poslao više zahtjeva prema poslužitelju, svaki zahtjev za jednu komponentu stranice, npr. HTML dokument, CSS dokument, skripte ili bilo koji drugi resurs koji se upotrebljavao na stranici. Preuzimanje stranice u dijelove podataka poznato je kao model stranica po stranica model(engl. ``	Page-by-Page model''). Za dohvat novog sadržaja stranice stranica se trebala ponovo učitati.

AJAX(Asynchronous Javascript and XML) tehnologija je donijela promjene i omogućila učitavanje dijelova stranice kroz asinkrone zahtjeve prema poslužitelju ali AJAX nije riješio sve probleme dinamičkih web stranica. Iako web preglednici sa AJAX-om imaju mogućnost zatražiti podatke sa servera i dinamički izmijeniti stranicu kada ti podatci stignu i dalje nisu imali mehanizam kojim bi znali da li server uopće ima nove podatke u slučajevima kada je to potrebno, npr. chat aplikacije. U takvim slučajevima se koristila tzv. ``polling'' tehnika.

\subsection{Polling}
``Polling'' tehnika je tehnika ostvarivanja poslužiteljskih dojava koja koristi periodičko slanje zahtjeva prema poslužitelju i na taj način doznaje da li poslužitelj ima relevantnih podataka koje bi klijent trebao prikazati. Ova tehnika ustvari nije prava ``push'' tehnologija jer bi takva tehnologija omogućila poslužitelju slanje podataka klijentu bez zahtjeva klijenta. Ovu tehniku možemo podijeliti na dvije kategorije: ``polling'' i ``long polling''.

``Polling'' tehnika se obično ostvaruje tako da klijent ostvari vezu prema poslužitelju, pošalje HTTP zahtjeve prema poslužitelju, poslužitelj odgovara klijentu i šalje mu podatke sa dojavom ukoliko je dostupna te se nakon što klijent primi odgovor veza raskida. Ovaj proces bi se periodički ponavljao te bi tako korisnik naizgled imao prave poslužiteljske dojave. Ova tehnika se obično koristila na internet stranicama pomoću periodičkih AJAX zahtjeva. Problemi ovakve implementacije poslužiteljskih dojava su očiti. Zbog potrebe za slanjem periodičkih HTTP zahtjeva koji su često i bespotrebnih poslužitelja se tjera na nepotrebnu obradu velikog broja zahtjeva što zahtjeva bolji i skuplji hardver ali i povećava internet promet zbog učestalih zahtjeva. 

Sustavi koji upotrebljavaju ``polling'' tehniku su ne skalabilni jer veći broj korisnika drastično povećava broj zahtjeva koje server mora obrađivati što je skupo i ne održivo. Zbog navedenih problema sa normalnom ``polling'' tehnikom razvijena je tehnika ``long polling''. Ova tehnika je slična svom prethodniku ali se razlikuje u načinu na koji poslužitelj odgovara. Koristeći ovu tehniku klijent mora ostvariti vezu sa poslužiteljom, poslati HTTP zahtjev prema poslužitelju ali poslužitelj neće odmah odgovoriti. Kod HTTP-a TCP veza se održava sve dok klijent ne dobije odgovor. Ova činjenica je ovdje iskorištena na način da će poslužitelj pričekati dok relevantni podatci ili dojave ne budu dostupne pa će tek onda kada je to potrebno poslati odgovor klijentu. Klijent nakon što zaprimi odgovor šalje novi zahtjev poslužitelju i proces se ponavlja. Ako se ipak zbog nekih razloga veza raskine prije nego što poslužitelj pošalje odgovor klijent pokušava ostvariti novu vezu i poslati novi zahtjev. Iako se ovom tehnikom rješava problem velikog broja zahtjeva stvara se novi problem. Većina modernih poslužitelja radi na način da za svaki zahtjev stvara novi proces ili dretvu i nakon obrade zahtjeva prekida proces ili dretvu ili zahtjeve predaje dretvi iz bazena dretvi nakon obrade zahtjeva  vraća dretvu u bazen dretvi. Problem je što koristeći ovu tehniku većinu vremena poslužitelj čeka podatke koje treba poslati a za to vrijeme ima proces ili dretvu koja ne radi ništa osim što koristi resurse poslužitelja koji bi se mogu koristiti za ostale zadatke. Još gori je problem ukoliko se koristi bazen dretvi jer može doći do situacije u kojoj sve dretve iz bazena čekaju podatke pa nema ni jedne dretve dostupne za obradu novih zahtjeva koji čekaju u redu ili se odbacuju.

\subsection{Streaming}
Pored ``polling'' tehnika imamo i ``streaming'' tehniku ostvarivanja poslužiteljskih dojava. Ova tehnika se ostvaruje pomoću jedne veze koju klijent ostvari sa poslužiteljem koju potom poslužitelj koristi za slanje dojava klijentu. Ako se odlučimo za implementaciju ove tehnike imamo dvije opcije: korištenje metode skrivenih iframe-ova ili korištenje višestrukog odgovora pomoću XMLHttpRequest objekta koji se koristi pri slanju AJAX zahtjeva.

``iframe'' je HTML element koji se koristi za ugradnju dokumenta unutar drugog HTML dokumenta. Pri implementaciji streaming Comet tehnike može se koristiti skriveni iframe element čiji će ``src'' atribut pokazivati na URL s kojeg će poslužitelj slati dojave. Svaki put kada poslužitelj ima dojavu za klijenta on će tu dojavu zapakirati u Javascript skriptu koju će klijent dobiti kroz iframe element te će je potom izvršiti.

\section{WebSocket}
Povijesno, stvaranje web aplikacija koje trebaju dvosmjernu komunikaciju između klijenta i poslužitelja zahtijevala je korištenje HTTP-a na način na koji HTTP nije namijenjen. Jednostavnije riješenje bi bilo da se koristi jedna TCP veza. Upravo na tome je radila IETF(engl. Internet Engineering Task Force) i objavila pod RFC 6455 specifikacijom. Protokol se zove WebSocket i zajedno sa WebSocket API-ijem daje alternativu ``pollingu'' i sličnim tehnikama. WebSocket protokol pokušava riješiti ciljeve postojećih dvosmjernih HTTP tehnologija u kontekstu postojeće HTTP infrastrukture. Kao takav, osmišljen je za rad preko HTTP portova 80 i 443, kao i za podršku HTTP posrednika.

Protokol trenutno podržavaju svi poznatiji internet preglednici poput Firefox(PC i Android verzija), Chrome(PC i mobilna verzija), Safari(PC i iOS verzija), Opera(PC i mobilna verzija), Internet Explorer i Android browser.

Protokol se sastoji od dva dijela: rukovanja(engl ``handshake'') i prijenosa podataka.

\subsection{Rukovanje}
Klijent tijekom rukovanja poslužitelju šalje:
\begin{lstlisting}
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
\end{lstlisting}

Poslužitelj tijekom rukovanja klijentu šalje:
\begin{lstlisting}
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: chat
\end{lstlisting}

Klijent uključuje hostname u Host zaglavlje rukovanja prema tako da i klijent i poslužitelj mogu potvrditi da se slažu o tome koji je host u upotrebi.

Dodatna polja zaglavlja koriste se za odabir opcija u WebSocket protokolu. Tipične opcije dostupne u ovoj verziji su selektor podprotokola (``Sec-WebSocket-Protocol''), popis ekstenzije podrške od strane klijenta (``Sec-WebSocket-Extensions''), ``Origin'' zaglavlje itd. 

``Sec-WebSocket-Protocol'' zaglavlje zahtjeva može se upotrijebiti za označavanje podprotokola koje klijent podržava. Poslužitelj odabire jedan ili nijedan od prihvatljivih protokola i šalje tu vrijednost tijekom rukovanja kako bi naznačio da je odabrao taj protokol.

Rukovanje je slično HTTP-u dopuštajući poslužiteljima da obrađuju HTTP i WebSocket veze na istom portu. Kada se uspostavlja veza, komunikacija prelazi na dvosmjerni protokol koji ne odgovara HTTP protokolu. Uz ``Upgrade'' zaglavlje klijent šalje i ``Sec-WebSocket-Key'' zaglavlje koje sadrži nasumične oktet kodirane sa base64 algoritmom a poslužitelj odogovara sa hash vrijednosti tog ključa u ``Sec-WebSocket-Accept'' zaglavlju.

\subsection{Prijenos podataka}
Nakon rukovanja i klijent i poslužitelj mogu poslati podatke u oba smjera. WebSocket prijenosi zovu se poruke, gdje se jedna poruka može po želji podijeliti na više okvira podataka. To može omogućiti slanje poruka gdje su početni podaci dostupni, ali cjelokupna duljina poruke je nepoznata (šalje se jedan podatkovni okvir nakon drugog dok se ne postigne kraj i označeno s bitom FIN). Uz proširenja protokola, to se također može koristiti za multipleksiranje nekoliko veza istovremeno. 

Svaki okvir ima svoju vrstu ali svi okviri koji čine jednu poruku moraju biti iste vrste. Općenito govoreći, postoje vrste za tekstualne podatke (koji se tumače kao tekst kodiran UTF-8 kodnom stranicom), binarne podatke (čija interpretacija ostaje do aplikacije) i kontrolne okvire (koji nisu namijenjeni za prijenos podataka za aplikaciju Ali umjesto toga za signalizaciju na razini protokola, kao da signalizira da veza bude zatvorena). Ova verzija protokola definira šest vrsta okvira i ostavlja deset rezerviranih za buduću upotrebu.

\section{Firebase Cloud Messaging (FCM)}

\subsection{Povijest}
Pojavom Android pametnih mobilnih telefona Google, kompanija iza Androida, tražila je riješenje za omogućivanje dvosmjerne komunikacije između Android aplikacija i poslužitelja. Postojeća rješenja nisu bila dovoljno dobra za mobilne uređaje. Jedan od razloga je da korisnik mobilnog uređaja može od jednom imati veliki broj aplikacija koje zahtjevaju opciju poslužiteljskih dojava a postojeće tehnologije su koristile jednu vezu po aplikaciji. Problem je što su mobilni uređaji relativno slabiji od osobnih uređaja i nisu bili u mogućnosti koristiti veliki broj veza odjednom.

Prva verzija protokola nazvala se AC2DM(engl. Android Cloud to Device Messaging). Protokol je omogućavao sve aplikacije primaju poslužiteljske dojave preko jedne veze sa Google-ovim poslužiteljem. GCM(engl. Google Cloud Messaging) usluga najavljena je u lipnju 2012. kao nasljednik protokola Android Cloud to Device Messaging. Poboljšanja su uključivala poboljšanja za provjeru autentičnosti i isporuke, nove krajnje točke API-ja i parametre za razmjenu poruka, te uklanjanje ograničenja na broj odaslanih poruka i veličine poruka. 2014 godine Google preuzima tvrtku Firebase i pod imenom Firebase Cloud Messaging izbacuje protokol koji je sada dostupan na Android i iOS pametnim mobilnim uređajima ali i na klasičnim web aplikacijama.

\subsection{Prijava na uslugu}
Firebase Cloud Messaging protokol radi na način da klijent koji na svom uređaju ima barem jednu aplikaciju koju koristi FCM protokol mora ostvariti vezu sa FCM poslužiteljima. Na Android uređajima svaka aplikacija mora imati servis koji će inicirati vezu sa FCM poslužiteljem i dobiti token jedinstven za svaku aplikaciju. Nakon što klijent dobije token on ga šalje svom poslužitelju koji bi trebao token spremiti ukoliko planira slati dojave tom klijentu. 

Klijent isto tako ima mogućnost prijave na razne teme. Teme su skupine klijenata koji žele primati iste dojave a svaka tema se identificira pomoću svog jedinstvenog imena. FCM poslužitelj pamti koji klijenti su se pretplatili na koje teme te koriste tu informaciju prilikom slanja dojave. 

\subsection{Slanje dojava i podataka}
Kada poslužitelj poželi poslati dojavu korisniku on za to koristi token koji je prije toga dobio i FCM poslužitelje. Na FCM poslužitelj šalje JSON objekt preko HTTP ili XMLL protokola. JSON objekt se sastoji od dva atributa: ``to'' ili ``condition'', ``notification'' i ``data''.

Prvi atribut može biti ``to'' ili ``condition'' i oba služe za određivanje klijenta ili više njih kome će slati dojava. Kod atributa ``to'' to može biti token koji je prije toga klijent poslao svom poslužitelju ili može biti ime teme. Vrijednost atributa ``condition'' sadrži neke uvijete koje primatelji moraju ispunjavati, npr. ``"condition": "'dogs' in topics || 'cats' in topics"'' znači da će se dojava poslati klijentima koji su pretplaćeni na teme ``dogs'' ili ``cats''.U oba slučaja FCM poslužitelj koristi ovaj podatak da razluči kome treba poslati dojavu.

Atribut ``notification'' se koristi za slanje dojava koje će se prikazati u dijelu za dojave na klijentskom operacijskom sustavu. Ovaj atribut je objekt koji se sastoji od atributa poput ``body'', ``title'', ``icon'', itd. koji određuju informacije koje će se prenijeti ali i koja će se ikonica prikazati uz dojavu ili koji zvuk će se oglasiti prilikom primitka dojave.

Atribut ``data'' se koristi ukoliko se treba poslati veća količina podataka. Pomoću ovog atributa može se poslati do 4kB podataka u obliku ključ-vrijednost. iOS klijent će ove podatke primiti tek kada klijentska aplikacija dođe u prednji plan dok će Android aplikacija obraditi podatke i kad je u pozadini. U slučaju ako se šalju i ``notification'' i ``data'' atribut dojava će se prikazati i ako je aplikacija u pozadini dok će se ``data'' atribut obraditi tek kada aplikacija dođe u prednji plan.

\begin{lstlisting}
{
    "to" : "APA91bHun4MxP5egoKMwt2...",
    "notification" : {
      "body" : "great match!",
      "title" : "Portugal vs. Denmark",
      "icon" : "myicon"
    },
    "data" : {
      "Nick" : "Mario",
      "Room" : "PortugalVSDenmark"
    }
}
\end{lstlisting}

\section{Apple Push Notification Service}

Prvi pametni mobilni uređaj iPhone kompanije Apple pokrenuo je revoluciju u razvoju mobilnih uređaja i izmjenio način na koji korisnici koriste svoje mobilne uređaje. Veliki broj aplikacija se oslanjao na poslužiteljske dojave ali nije bilo adekvatnog rješenja. Apple se susreo sa istim problemima kao i njihov konkurent Google pa su se odlučili za izradu vlastitog servisa za poslužiteljske dojave.

2008 godine napravljen je servis nazvan APNs(engl. Apple Push Notification Service). Usluga podržava iOS pametne mobilne telefone, watchOS pametne satove, tvOS pametne televizore i macOS osobna i prijenosna računala.

Princip rada je sličan Firebase Cloud Messaging usluzi. Klijenti se registriraju kod APNs poslužitelja i APNs vodi računa o vezama sa klijentima. Poslužitelj kada poželi poslati dojavu šalje zahtjev prema APNs poslužitelju koji šalje te dojave klijentima.

\subsection{Prijava na uslugu}

Po početnom pokretanju aplikacije na korisničkom uređaju sustav automatski uspostavlja akreditiranu, šifriranu i postojanu IP vezu između aplikacije i APNs poslužitelja. Ta veza omogućuje vašoj aplikaciji da izvrši postavljanje kako bi omogućila primanje dojava. Ako je proces autentikacije uspješno izvršen klijentska aplikacija dobije token. Svaki token je jedinstven za aplikaciju i uređaj koji korisnik koristi.

\subsection{Slanje dojava i podataka}

Poslužitelj pri slanju dojave šalje zahtjev APNs poslužitelju preko HTTP/2 protokola. U tijelu zahtjeva treba poslati JSON objekt koji ne prelazi veličinu od 4kB ili 	VoIP poruku koja ne prelazi 5kB.

JSON objekt se sastoji od atributa ``aps'' i drugih atributa koji nemaju određeno ime a koriste su za prijenos podataka u obliku ključ-vrijednost. Vrijednost atributa ``aps'' je objekt koji sadrži atribute ``title'', ``body'', ``alert'', ``sound'', itd. koji određuju sadržaj notifikacije i način prikaza. Ako se želi poslati tzv. ``tiha'' dojava pošalje se zahtjev sa sadržajem:

\begin{lstlisting}
{
    "aps" : {
        "content-available" : 1
    }
}
\end{lstlisting}

Tiha dojava označava aplikaciji da ima dostupne dojave i da ih može dohvatiti kada to poželi.

\chapter{Arhitektura aplikacije}

\section{Ideja}
Ideja je napraviti aplikaciju koja korisniku omogućava praćenje događaja poput koncerata, rođendana i sl. i informacija vezanih uz taj događaj. Isto tako korisnici trebaju imati mogućnost kreiranja događaja za koje mogu definirati nekakve atribute poput naziva događaja, opisa, datuma i sl. Svi pratioci koji prate određeni događaj bi trebali dobiti dojavu kada se kreator događaja odluči izmijeniti neki od atributa događaja ili odluči poslati poruku vezanu uz taj događaj. Tako će se dobiti aplikacija koja će biti koristan alat pri organizaciji manjih događaja ali i većih događaja. Aplikacija se lako može pretvoriti u manju društvenu mrežu na kojoj će fokus biti na događajima, a ne na objavama kao većina društvenih mreža.

\section{Zahtjevi}

Aplikacija se sastoji od poslužiteljskog dijela i klijentskog dijela. Poslužiteljski dio je odgovoran za autentikaciju korisnika, za obradu podataka i za slanje dojava dok je klijentski dio odgovoran za priakz podataka i primanje dojava.

Aplikacija treba imati mogućnosti registracije i prijave kako bi raspoznala korisnike i pamtila njihove odabire. Pri registraciji korisnici bi trebali unijeti svoje osobne podatke, ime njihovog budućeg računa i lozinku.

Poslužiteljske dojave se ovdje koriste kao način na koji se obavješćuje pretplatnika o izmjenama u događajima koje prate. Pošto izmjene mogu biti veoma bitne korisniku vrlo je bitno da se poruke dostave u što kraćem roku ali i da se ne izgube ukoliko je korisnikov Android uređaj ugašen.

Korisnik na klijentskoj aplikaciji isto tako mora biti u mogućnosti pretraživati događaje da bi ih mogao označiti kao događaje koje prati.

\chapter{Implementacija}

\chapter{Zaključak}
Zaključak.

\bibliography{literatura}
\bibliographystyle{fer}

\begin{sazetak}
Sažetak na hrvatskom jeziku.

\kljucnerijeci{Ključne riječi, odvojene zarezima.}
\end{sazetak}

% TODO: Navedite naslov na engleskom jeziku.
\engtitle{Application of Server Push Notifications in Web Service Development}
\begin{abstract}
Abstract.

\keywords{Keywords.}
\end{abstract}

\end{document}
